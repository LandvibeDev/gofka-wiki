# 4. 카프카 컨슈머

## 4.1 컨슈머 주요 옵션  
- `boostrap.servers` 
  - 카프카 클러스터는 모든 노드가 클라이언트의 요청을 받을 수 있습니다.
  - 컨슈머가 카프카에 접근하기 위한 접속 정보
  - 예시) `gofka-kafka01:9092,gofka-kafka02:9093,gofka-kafka03:9094`
  - 특정 호스트가 접속이 불가능할 때 다른 호스트로 연결을 위해서 모든 호스트의 접속정보를 적어 주는 것이 좋습니다.
- `group.id`
  - 컨슈머가 속한 컨슈머 그룹을 식별하는 식별자입니다.
- `enable.auto.commit`
   - 백그라운드에서 `auto.commit.interval.ms` 시간마다 주기적으로 오프셋을 커밋합니다.
- `auto.commit.interval.ms`
   - 주기적으로 오프셋을 커밋하는 시간
- `auto.offset.rest`
   - 초기 오프셋이 없거나 현재 오프셋이 더 이상 존재하지 않는 경우 아래 옵션으로 리셋합니다.
   - `earliest`: 가장 초기의 오프셋 값으로 설정합니다.
   - `latest`: 가장 마지막의 오프셋 값으로 설정합니다.
   - `none`: 이전 오프셋값을 찾지 못하면 에러를 나타냅니다.
- `fetch-min.bytes`
  - 한번에 가져올 수 있는 최소 데이터 사이즈
  - 지정한 사이즈보다 작으면 요청에 응답하지 않고 데이터가 누적될 때 까지 기다립니다.
- `fetch.max.bytes`
   - 한번에 가져올 수 있는 최대 데이터 사이즈
- `fetch.max.wait.ms`
   - `fetch.max.bytes`에 의해 설정된 데이터보다 적은 경우 요청에 응답을 기다리는 최대 시간
- `request.timeout.ms`
   - 요청에 대해 응답을 기다리는 최대 시간
- `session.timeout.ms`
   - 컨슈머와 브로커 사이의 세션 타임 아웃 시간
   - 브로커가 컨슈머가 살아있는 것으로 판단하는 시간
   - 컨슈머가 세션 타임아웃 시간동안 heartbeat를 보내지 않으면, 해당 컨슈머에 장애가 발생한 것으로 판단하고 컨슈머 그룹을 리밸런스(rebalance)를 시도합니다.
   - `heartbeat.interval.ms` 시간 보다 높게 설정되어야 합니다.
- `heartbeat.interval.ms`
   - 컨슈머 그룹 코디네이터에게 얼마나 자주 `poll()` 메소드로 heartbeat를 보낼지 조정합니다.
   - `session.timeout.ms` 시간 보다 낮게 설정되어야 합니다. (일반적으로 1/3 정도로 설정합니다.)
- `max.poll.records`
   - 단일 호출 `poll()`에 대한 최대 레코드 수를 조정합니다.
   - 이 옵션을 통해 앱이 polling loop에서 데이터양을 조정할 수 있습니다.
- `max.poll.interval.ms`
   - 컨슈머가 단순히 heartbeat만 보내고 실제로는 `poll()` 메소드로 메세지를 가져가지 않는 경우가 있을 수도 있습니다.
   - 이러한 경우 컨슈머가 무한정으로 파티션을 점유할 수 없도록 주기적으로 `poll()`을 호출하지 않으면 장애라고 판단하여 컨슈머 그룹에서 제외합니다.


## 4.2 콘솔 컨슈머로 메세지 가져오기  
책보고 따라해보세요^^

## 4.3 파티션과 메세지 순서  

![](assets/2019-07-25-00-17-12.png)
- 카프카 컨슈머에서의 메세지 순서는 동일한 파티션 내에서는 프로듀서가 생성한 순서와 동일하게 처리합니다.  
- 다른 파티션에 있는 메세지와는 순서를 보장하지 않습니다.  

### 순서를 보장하고 싶을 때는?
- 순서를 보장하고싶으면 **파티션 개수를 1**로 설정해야합니다.
- 메세지의 분산처리가 불가능하기 때문에 처리량의 한계가 존재(복제는 되기 때문에 HA는 보장)


## 4.4 컨슈머 그룹  


## 4.5 커밋과 오프셋  